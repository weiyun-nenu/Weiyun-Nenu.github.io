<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>黑白棋 AI</title>
    <style>
        body {
            background-color: #1e2733; /* 对应 COLOR_BG */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            color: #c8d2e6;
            font-family: "Microsoft YaHei", sans-serif;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        canvas {
            cursor: pointer;
            display: block;
        }
        .status-bar {
            width: 640px;
            height: 80px;
            background-color: #141a23;
            display: flex;
            align-items: center;
            padding-left: 30px;
            font-size: 22px;
            box-sizing: border-box;
        }
        .menu-overlay {
            position: absolute;
            top: 0; left: 0; width: 640px; height: 640px;
            background: rgba(18, 23, 33, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .btn {
            width: 280px;
            padding: 15px;
            margin: 10px;
            background: #2d3e50;
            border: 1px solid #4a6075;
            color: white;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            transition: background 0.3s;
        }
        .btn:hover { background: #3d5269; }
        h1 { font-size: 52px; margin-bottom: 40px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="menu" class="menu-overlay">
        <h1>黑白棋 AI</h1>
        <div class="btn" onclick="startGame(1)">玩家持黑 (先手)</div>
        <div class="btn" onclick="startGame(2)">玩家持白 (后手)</div>
    </div>
    
    <canvas id="board" width="640" height="640"></canvas>
    <div class="status-bar" id="status">等待开始...</div>
</div>

<script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const S = 640;
    const G = S / 8;

    // 颜色配置
    const COLORS = {
        BOARD: '#2d3e50',
        GRID: '#4a6075',
        ACCENT: '#64d2ff',
        BLACK: '#0f0f0f',
        WHITE: '#fafaff'
    };

    // 权重矩阵
    const WEIGHTS = [
        [100, -25, 10, 5, 5, 10, -25, 100],
        [-25, -60, -2, -2, -2, -2, -60, -25],
        [10, -2, 5, 2, 2, 5, -2, 10],
        [5, -2, 2, 1, 1, 2, -2, 5],
        [5, -2, 2, 1, 1, 2, -2, 5],
        [10, -2, 5, 2, 2, 5, -2, 10],
        [-25, -60, -2, -2, -2, -2, -60, -25],
        [100, -25, 10, 5, 5, 10, -25, 100]
    ];

    let board = [];
    let human = 1, ai = 2, turn = 1;
    let gameOver = false;

    // 初始化棋盘
    function initBoard() {
        board = Array.from({length: 8}, () => Array(8).fill(0));
        board[3][3] = board[4][4] = 2;
        board[3][4] = board[4][3] = 1;
    }

    function startGame(playerColor) {
        human = playerColor;
        ai = 3 - playerColor;
        turn = 1;
        gameOver = false;
        document.getElementById('menu').style.display = 'none';
        initBoard();
        draw();
        if (turn === ai) setTimeout(aiMove, 600);
    }

    // 核心逻辑：落子合法性
    function isValidMove(b, r, c, p) {
        if (r < 0 || r >= 8 || c < 0 || c >= 8 || b[r][c] !== 0) return false;
        const opp = 3 - p;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (let [dr, dc] of dirs) {
            let nr = r + dr, nc = c + dc, foundOpp = false;
            while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                if (b[nr][nc] === opp) foundOpp = true;
                else if (b[nr][nc] === p) {
                    if (foundOpp) return true;
                    break;
                } else break;
                nr += dr; nc += dc;
            }
        }
        return false;
    }

    function getValidMoves(b, p) {
        let moves = [];
        for (let r = 0; r < 8; r++)
            for (let c = 0; c < 8; c++)
                if (isValidMove(b, r, c, p)) moves.push({r, c});
        return moves;
    }

    function makeMove(b, row, col, p) {
        let nb = b.map(row => [...row]);
        nb[row][col] = p;
        const opp = 3 - p;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (let [dr, dc] of dirs) {
            let nr = row + dr, nc = col + dc, toFlip = [];
            while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                if (nb[nr][nc] === opp) toFlip.push([nr, nc]);
                else if (nb[nr][nc] === p) {
                    toFlip.forEach(([fr, fc]) => nb[fr][fc] = p);
                    break;
                } else break;
                nr += dr; nc += dc;
            }
        }
        return nb;
    }

    // AI 评分引擎
    function evaluate(b, p) {
        let score = 0, opp = 3 - p;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (b[r][c] === p) score += WEIGHTS[r][c];
                else if (b[r][c] === opp) score -= WEIGHTS[r][c];
            }
        }
        return score * 10 + (getValidMoves(b, p).length - getValidMoves(b, opp).length) * 20;
    }

    // Minimax 算法
    function minimax(b, depth, alpha, beta, maximizing, p) {
        if (depth === 0) return {score: evaluate(b, p)};
        let curr = maximizing ? p : 3 - p;
        let moves = getValidMoves(b, curr);
        if (moves.length === 0) return minimax(b, depth - 1, alpha, beta, !maximizing, p);

        let bestMove = null;
        if (maximizing) {
            let maxEval = -Infinity;
            for (let m of moves) {
                let ev = minimax(makeMove(b, m.r, m.c, curr), depth - 1, alpha, beta, false, p).score;
                if (ev > maxEval) { maxEval = ev; bestMove = m; }
                alpha = Math.max(alpha, ev);
                if (beta <= alpha) break;
            }
            return {score: maxEval, move: bestMove};
        } else {
            let minEval = Infinity;
            for (let m of moves) {
                let ev = minimax(makeMove(b, m.r, m.c, curr), depth - 1, alpha, beta, true, p).score;
                if (ev < minEval) { minEval = ev; bestMove = m; }
                beta = Math.min(beta, ev);
                if (beta <= alpha) break;
            }
            return {score: minEval, move: bestMove};
        }
    }

    function aiMove() {
        if (gameOver) return;
        let res = minimax(board, 4, -Infinity, Infinity, true, ai);
        if (res.move) {
            board = makeMove(board, res.move.r, res.move.c, ai);
        }
        nextTurn();
    }

    function nextTurn() {
        turn = 3 - turn;
        let moves = getValidMoves(board, turn);
        if (moves.length === 0) {
            turn = 3 - turn;
            if (getValidMoves(board, turn).length === 0) {
                gameOver = true;
            } else if (turn === ai) setTimeout(aiMove, 600);
        } else if (turn === ai) {
            setTimeout(aiMove, 600);
        }
        draw();
    }

    // 绘制函数
    function draw() {
        ctx.clearRect(0, 0, S, S);
        let validMoves = getValidMoves(board, turn);

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                ctx.fillStyle = COLORS.BOARD;
                ctx.fillRect(c * G, r * G, G, G);
                ctx.strokeStyle = COLORS.GRID;
                ctx.strokeRect(c * G, r * G, G, G);

                let cx = c * G + G/2, cy = r * G + G/2, rad = G/2 - 8;
                if (board[r][c] !== 0) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, rad, 0, Math.PI*2);
                    ctx.fillStyle = board[r][c] === 1 ? COLORS.BLACK : COLORS.WHITE;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (!gameOver && turn === human && validMoves.some(m => m.r === r && m.c === c)) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, 8, 0, Math.PI*2);
                    ctx.strokeStyle = COLORS.ACCENT;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // 状态栏更新
        let bCount = board.flat().filter(x => x === 1).length;
        let wCount = board.flat().filter(x => x === 2).length;
        let statusText = `黑子: ${bCount}  白子: ${wCount} | `;
        if (gameOver) {
            let winMsg = bCount === wCount ? "平局" : (bCount > wCount && human === 1 || wCount > bCount && human === 2 ? "你赢了！" : "AI 赢了");
            statusText += winMsg;
        } else {
            statusText += (turn === human ? "你的回合" : "AI 思考中...");
        }
        document.getElementById('status').innerText = statusText;
    }

    canvas.addEventListener('click', (e) => {
        if (turn !== human || gameOver) return;
        const rect = canvas.getBoundingClientRect();
        const c = Math.floor((e.clientX - rect.left) / G);
        const r = Math.floor((e.clientY - rect.top) / G);
        if (isValidMove(board, r, c, human)) {
            board = makeMove(board, r, c, human);
            nextTurn();
        }
    });

</script>
</body>
</html>

</html>
