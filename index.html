<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>é»‘ç™½æ£‹ AI - å®Œæ•´é›†æˆç‰ˆ</title>
    <style>
        <style>@font-face {
            font-family: 'MyFont';
            src: url('./fonts/å°æ¥·.ttf') format('truetype');
        }

        body {
            background-color: #1e2733;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            color: #fefefe;
            font-family: 'MyFont', "Microsoft YaHei", sans-serif;
            /* æ·»åŠ  MyFont */
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: pointer;
            background-color: #2d3e50;
        }

        .status-bar {
            width: 640px;
            height: 70px;
            background-color: #141a23;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            font-size: 18px;
            box-sizing: border-box;
            border-top: 1px solid #4a6075;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 640px;
            background: rgba(18, 23, 33, 0.96);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            overflow-y: auto;
        }

        .btn-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 320px;
            margin-bottom: 30px;
        }

        .btn {
            width: 100%;
            padding: 14px 0;
            background: #2d3e50;
            border: 2px solid #4a6075;
            color: white;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-size: 17px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-sizing: border-box;
            user-select: none;
        }

        .btn:hover {
            background: #3d5269;
            border-color: #64d2ff;
            color: #64d2ff;
        }

        .btn.selected,
        .btn.action:active {
            background: rgba(100, 210, 255, 0.15);
            border-color: #64d2ff;
            color: #64d2ff;
            box-shadow: 0 0 15px rgba(100, 210, 255, 0.2);
        }

        .btn.action:hover {
            border-color: #64d2ff;
            box-shadow: 0 0 15px rgba(100, 210, 255, 0.3);
        }

        h1 {
            font-size: 48px;
            margin: 20px 0 30px;
            color: #fff;
            letter-spacing: 4px;
        }

        h2 {
            font-size: 15px;
            margin-bottom: 12px;
            color: #64d2ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #result-overlay {
            display: none;
            padding: 20px;
        }

        .evaluation-box {
            background: rgba(45, 62, 80, 0.5);
            border: 1px solid #4a6075;
            border-radius: 8px;
            padding: 20px;
            width: 400px;
            max-width: 90%;
            margin: 20px 0;
            text-align: left;
        }

        .eval-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #4a6075;
        }

        .eval-item:last-child {
            border-bottom: none;
        }

        .eval-label {
            color: #a0a0a0;
            font-size: 15px;
        }

        .eval-value {
            color: #64d2ff;
            font-size: 18px;
            font-weight: bold;
        }

        .tips-box {
            background: rgba(100, 210, 255, 0.05);
            border-left: 3px solid #64d2ff;
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }

        .tip-item {
            color: #fefefe;
            font-size: 14px;
            line-height: 1.8;
            margin: 5px 0;
        }

        .tip-item:before {
            content: "â€¢ ";
            color: #64d2ff;
            font-weight: bold;
        }

        .rating-badge {
            display: inline-block;
            padding: 8px 20px;
            background: linear-gradient(135deg, #64d2ff, #4a9eff);
            border-radius: 20px;
            font-size: 22px;
            font-weight: bold;
            color: white;
            margin: 10px 0;
            box-shadow: 0 4px 15px rgba(100, 210, 255, 0.3);
        }

        .loading {
            color: #64d2ff;
            font-size: 14px;
            margin-top: 10px;
        }

        /* APIé…ç½®è¾“å…¥æ¡† */
        .api-config {
            width: 320px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(45, 62, 80, 0.3);
            border: 1px solid #4a6075;
            border-radius: 8px;
        }

        .api-config input {
            width: 100%;
            padding: 10px;
            background: #2d3e50;
            border: 1px solid #4a6075;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
            margin-top: 8px;
        }

        .api-config input::placeholder {
            color: #6a7a8f;
        }

        .api-config label {
            color: #a0a0a0;
            font-size: 13px;
            display: block;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="menu" class="overlay">
            <h1>é»‘ç™½æ£‹ AI</h1>

            <h2>ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©å¯¹å¼ˆéš¾åº¦</h2>
            <div class="btn-list">
                <div class="btn diff-option" onclick="setDiff(3, this)">å…¥é—¨æ°´å¹³ (3å±‚æœç´¢)</div>
                <div class="btn diff-option" onclick="setDiff(4, this)">è¿›é˜¶æŒ‘æˆ˜ (4å±‚æœç´¢)</div>
                <div class="btn diff-option selected" onclick="setDiff(5, this)">å¤§å¸ˆå¯¹å†³ (5å±‚æœç´¢)</div>
            </div>

            <h2>ç¬¬äºŒæ­¥ï¼šé€‰æ‹©å…ˆåæ‰‹å¹¶å¼€å§‹</h2>
            <div class="btn-list">
                <div class="btn action" onclick="startGame(1)">ç©å®¶æŒé»‘ (å…ˆæ‰‹)</div>
                <div class="btn action" onclick="startGame(2)">ç©å®¶æŒç™½ (åæ‰‹)</div>
            </div>

            <div class="api-config">
                <input type="text" id="api-endpoint" placeholder="ç•™ç©ºä½¿ç”¨æœ¬åœ°è¯„ä»·">
            </div>
        </div>

        <div id="result-overlay" class="overlay">
            <h1 id="res-title">å¯¹å±€ç»“æŸ</h1>
            <h2 id="res-score" style="color: #fff; font-size: 20px;">æ¯”åˆ†ç»Ÿè®¡</h2>

            <div class="evaluation-box" id="eval-box">
                <div id="eval-loading" class="loading">æ­£åœ¨åˆ†æå¯¹å±€...</div>
                <div id="eval-content" style="display:none;">
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div class="rating-badge" id="rating-badge">åˆ†æä¸­</div>
                    </div>
                    <div class="eval-item">
                        <span class="eval-label">æœ€ä½³æ‰‹ç‡</span>
                        <span class="eval-value" id="best-move-rate">--</span>
                    </div>
                    <div class="eval-item">
                        <span class="eval-label">å¹³å‡ç”¨æ—¶</span>
                        <span class="eval-value" id="avg-think-time">--</span>
                    </div>
                    <div class="eval-item">
                        <span class="eval-label">æ€»æ­¥æ•°</span>
                        <span class="eval-value" id="total-moves">--</span>
                    </div>
                    <div class="eval-item">
                        <span class="eval-label">å¯¹å±€æ—¶é•¿</span>
                        <span class="eval-value" id="game-duration">--</span>
                    </div>
                    <div class="tips-box" id="tips-box" style="display:none;">
                        <div style="color: #64d2ff; font-weight: bold; margin-bottom: 10px;">ğŸ’¡ æ”¹è¿›å»ºè®®</div>
                        <div id="tips-content"></div>
                    </div>
                </div>
            </div>

            <div class="btn-list" style="margin-top: 20px;">
                <div class="btn action" onclick="backToMenu()">è¿”å›ä¸»èœå•</div>
            </div>
        </div>

        <canvas id="board" width="640" height="640"></canvas>

        <div class="status-bar">
            <div id="status">å‡†å¤‡å°±ç»ª</div>
            <div id="score">é»‘: 2 | ç™½: 2</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const S = 640, G = S / 8;
        const COLORS = {
            BOARD: '#2d3e50', GRID: '#4a6075',
            ACCENT: '#64d2ff', BLACK: '#0f0f0f', WHITE: '#fafaff'
        };
        const WEIGHTS = [
            [100, -25, 10, 5, 5, 10, -25, 100],
            [-25, -60, -2, -2, -2, -2, -60, -25],
            [10, -2, 5, 2, 2, 5, -2, 10],
            [5, -2, 2, 1, 1, 2, -2, 5],
            [5, -2, 2, 1, 1, 2, -2, 5],
            [10, -2, 5, 2, 2, 5, -2, 10],
            [-25, -60, -2, -2, -2, -2, -60, -25],
            [100, -25, 10, 5, 5, 10, -25, 100]
        ];

        let board = [], human = 1, ai = 2, turn = 1, gameOver = false, searchDepth = 5;

        // ========== å¯¹å±€è®°å½•ç³»ç»Ÿ ==========
        let gameRecord = {
            difficulty: 5,
            playerColor: 1,
            moves: [],
            startTime: null,
            endTime: null,
            lastMoveTime: null
        };

        function setDiff(d, el) {
            searchDepth = d;
            document.querySelectorAll('.diff-option').forEach(b => b.classList.remove('selected'));
            el.classList.add('selected');
        }

        function backToMenu() {
            document.getElementById('result-overlay').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
        }

        function initBoard() {
            board = Array.from({ length: 8 }, () => Array(8).fill(0));
            board[3][3] = board[4][4] = 2;
            board[3][4] = board[4][3] = 1;
        }

        function startGame(playerColor) {
            human = playerColor;
            ai = 3 - playerColor;
            turn = 1;
            gameOver = false;

            // åˆå§‹åŒ–å¯¹å±€è®°å½•
            gameRecord = {
                difficulty: searchDepth,
                playerColor: playerColor,
                moves: [],
                startTime: Date.now(),
                endTime: null,
                lastMoveTime: Date.now()
            };

            document.getElementById('menu').style.display = 'none';
            initBoard();
            draw();
            if (turn === ai) setTimeout(aiMove, 600);
        }

        function isValidMove(b, r, c, p) {
            if (r < 0 || r >= 8 || c < 0 || c >= 8 || b[r][c] !== 0) return false;
            const opp = 3 - p;
            const dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            for (let [dr, dc] of dirs) {
                let nr = r + dr, nc = c + dc, foundOpp = false;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                    if (b[nr][nc] === opp) foundOpp = true;
                    else if (b[nr][nc] === p) { if (foundOpp) return true; break; }
                    else break;
                    nr += dr; nc += dc;
                }
            }
            return false;
        }

        function getValidMoves(b, p) {
            let moves = [];
            for (let r = 0; r < 8; r++)
                for (let c = 0; c < 8; c++)
                    if (isValidMove(b, r, c, p)) moves.push({ r, c });
            return moves;
        }

        function makeMove(b, row, col, p, recordMove = false) {
            let nb = b.map(row => [...row]);
            nb[row][col] = p;
            const opp = 3 - p;
            const dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            for (let [dr, dc] of dirs) {
                let nr = row + dr, nc = col + dc, toFlip = [];
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                    if (nb[nr][nc] === opp) toFlip.push([nr, nc]);
                    else if (nb[nr][nc] === p) { toFlip.forEach(([fr, fc]) => nb[fr][fc] = p); break; }
                    else break;
                    nr += dr; nc += dc;
                }
            }

            // ========== è®°å½•èµ°æ³• ==========
            if (recordMove && !gameOver) {
                const currentTime = Date.now();
                const thinkTime = currentTime - gameRecord.lastMoveTime;
                gameRecord.lastMoveTime = currentTime;

                const allMoves = getValidMoves(b, p);
                const moveScores = allMoves.map(m => ({
                    pos: m,
                    score: evaluate(makeMove(b, m.r, m.c, p, false), p)
                }));
                const bestScore = Math.max(...moveScores.map(m => m.score));
                const currentScore = evaluate(nb, p);

                // æ‰¾åˆ°æœ€ä½³èµ°æ³•ä½ç½®
                const bestMoves = moveScores.filter(m => m.score === bestScore);
                const isBestMove = bestMoves.some(m => m.pos.r === row && m.pos.c === col);

                gameRecord.moves.push({
                    player: p,
                    position: { row, col },
                    timestamp: currentTime - gameRecord.startTime,
                    thinkTime: p === human ? thinkTime : 0,
                    evaluation: currentScore,
                    isBestMove: isBestMove,
                    alternatives: allMoves.length,
                    bestScore: bestScore,
                    actualScore: currentScore,
                    missedPoints: isBestMove ? 0 : bestScore - currentScore
                });
            }

            return nb;
        }

        function evaluate(b, p) {
            let score = 0, opp = 3 - p;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (b[r][c] === p) score += WEIGHTS[r][c];
                    else if (b[r][c] === opp) score -= WEIGHTS[r][c];
                }
            }
            return score * 10 + (getValidMoves(b, p).length - getValidMoves(b, opp).length) * 20;
        }

        function minimax(b, depth, alpha, beta, maximizing, p) {
            if (depth === 0) return { score: evaluate(b, p) };
            let curr = maximizing ? p : 3 - p;
            let moves = getValidMoves(b, curr);
            if (moves.length === 0) return minimax(b, depth - 1, alpha, beta, !maximizing, p);
            let bestMove = null;
            if (maximizing) {
                let maxEval = -Infinity;
                for (let m of moves) {
                    let ev = minimax(makeMove(b, m.r, m.c, curr, false), depth - 1, alpha, beta, false, p).score;
                    if (ev > maxEval) { maxEval = ev; bestMove = m; }
                    alpha = Math.max(alpha, ev); if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (let m of moves) {
                    let ev = minimax(makeMove(b, m.r, m.c, curr, false), depth - 1, alpha, beta, true, p).score;
                    if (ev < minEval) { minEval = ev; bestMove = m; }
                    beta = Math.min(beta, ev); if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        function aiMove() {
            if (gameOver) return;
            let res = minimax(board, searchDepth, -Infinity, Infinity, true, ai);
            if (res.move) board = makeMove(board, res.move.r, res.move.c, ai, true);
            nextTurn();
        }

        function nextTurn() {
            turn = 3 - turn;
            if (getValidMoves(board, turn).length === 0) {
                turn = 3 - turn;
                if (getValidMoves(board, turn).length === 0) {
                    gameOver = true;
                    showResult();
                } else if (turn === ai) setTimeout(aiMove, 600);
            } else if (turn === ai) setTimeout(aiMove, 600);
            draw();
        }

        // ========== å¯¹å±€è¯„ä»·ç³»ç»Ÿ ==========
        async function evaluateGame(record) {
            const apiEndpoint = document.getElementById('api-endpoint').value.trim();

            // å¦‚æœé…ç½®äº†APIåœ°å€ï¼Œå°è¯•è°ƒç”¨
            if (apiEndpoint) {
                try {
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            difficulty: record.difficulty,
                            playerColor: record.playerColor,
                            moves: record.moves,
                            duration: record.endTime - record.startTime,
                            finalScore: record.finalScore
                        })
                    });

                    if (response.ok) {
                        return await response.json();
                    }
                } catch (error) {
                    console.error('APIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è¯„ä»·:', error);
                }
            }

            // é™çº§åˆ°æœ¬åœ°è¯„ä»·
            return getLocalEvaluation(record);
        }

        function getLocalEvaluation(record) {
            const playerMoves = record.moves.filter(m => m.player === record.playerColor);
            const aiMoves = record.moves.filter(m => m.player !== record.playerColor);

            // è®¡ç®—æœ€ä½³æ‰‹ç‡
            const bestMoveCount = playerMoves.filter(m => m.isBestMove).length;
            const bestMoveRate = playerMoves.length > 0 ? bestMoveCount / playerMoves.length : 0;

            // è®¡ç®—å¹³å‡æ€è€ƒæ—¶é—´(æ’é™¤ç¬¬ä¸€æ­¥)
            const thinkTimes = playerMoves.slice(1).map(m => m.thinkTime).filter(t => t > 0);
            const avgThinkTime = thinkTimes.length > 0
                ? thinkTimes.reduce((a, b) => a + b, 0) / thinkTimes.length
                : 0;

            // è®¡ç®—å…³é”®å¤±è¯¯(æŸå¤±è¶…è¿‡100åˆ†çš„èµ°æ³•)
            const criticalMistakes = playerMoves.filter(m => m.missedPoints > 100);

            // è®¡ç®—å¼€å±€è¡¨ç°(å‰10æ­¥)
            const earlyMoves = playerMoves.slice(0, Math.min(10, playerMoves.length));
            const earlyBestRate = earlyMoves.length > 0
                ? earlyMoves.filter(m => m.isBestMove).length / earlyMoves.length
                : 0;

            // è¯„çº§ç³»ç»Ÿ
            let rating = 'åˆå­¦è€…';
            let ratingColor = '#ff9800';

            if (bestMoveRate >= 0.75) {
                rating = 'å¤§å¸ˆçº§';
                ratingColor = '#ffd700';
            } else if (bestMoveRate >= 0.60) {
                rating = 'é«˜æ‰‹';
                ratingColor = '#64d2ff';
            } else if (bestMoveRate >= 0.45) {
                rating = 'è¿›é˜¶';
                ratingColor = '#4caf50';
            } else if (bestMoveRate >= 0.30) {
                rating = 'å…¥é—¨';
                ratingColor = '#9c27b0';
            }

            // ç”Ÿæˆå»ºè®®
            const tips = [];

            if (earlyBestRate < 0.4) {
                tips.push('å¼€å±€é˜¶æ®µåº”å°½é‡æ§åˆ¶ä¸­å¿ƒåŒºåŸŸ');
            }

            if (criticalMistakes.length > 2) {
                tips.push('å‘ç°' + criticalMistakes.length + 'æ¬¡å…³é”®å¤±è¯¯ï¼Œä¸‹æ£‹å‰å¯ä»¥å¤šæ€è€ƒå‡ ç§’ï¼Œè¯„ä¼°å„ä¸ªä½ç½®çš„ä»·å€¼');
            }

            if (avgThinkTime < 2000 && bestMoveRate < 0.5) {
                tips.push('é€‚å½“å¢åŠ æ€è€ƒæ—¶é—´å¯ä»¥æé«˜å†³ç­–è´¨é‡ï¼Œä¸è¦æ€¥äºè½å­');
            }

            const playerScore = record.finalScore[record.playerColor === 1 ? 'black' : 'white'];
            const aiScore = record.finalScore[record.playerColor === 1 ? 'white' : 'black'];

            if (playerScore < aiScore && bestMoveRate < 0.4) {
                tips.push('å°è¯•æ§åˆ¶æ›´å¤šçš„å¯é€‰ä½ç½®ï¼ˆè¡ŒåŠ¨åŠ›ï¼‰ï¼Œé™åˆ¶å¯¹æ‰‹çš„é€‰æ‹©ç©ºé—´');
            }

            if (tips.length === 0) {
                if (bestMoveRate >= 0.7) {
                    tips.push('è¡¨ç°ä¼˜ç§€ï¼å¯ä»¥å°è¯•æ›´é«˜éš¾åº¦çš„æŒ‘æˆ˜');
                } else {
                    tips.push('ç»§ç»­ç»ƒä¹ ï¼Œæ³¨æ„è§‚å¯Ÿæ¯ä¸ªä½ç½®çš„æˆ˜ç•¥ä»·å€¼');
                }
            }

            return {
                rating: rating,
                ratingColor: ratingColor,
                bestMoveRate: (bestMoveRate * 100).toFixed(1) + '%',
                avgThinkTime: (avgThinkTime / 1000).toFixed(1) + 'ç§’',
                totalMoves: playerMoves.length,
                gameDuration: formatDuration(record.endTime - record.startTime),
                tips: tips,
                stats: {
                    bestMoveCount: bestMoveCount,
                    totalMoves: playerMoves.length,
                    criticalMistakes: criticalMistakes.length,
                    earlyBestRate: (earlyBestRate * 100).toFixed(0) + '%'
                }
            };
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            if (minutes > 0) {
                return minutes + 'åˆ†' + remainingSeconds + 'ç§’';
            }
            return seconds + 'ç§’';
        }

        async function showResult() {
            const b = board.flat().filter(x => x === 1).length;
            const w = board.flat().filter(x => x === 2).length;

            gameRecord.endTime = Date.now();
            gameRecord.finalScore = { black: b, white: w };

            // æ˜¾ç¤ºåŸºç¡€ç»“æœ
            const resTitle = document.getElementById('res-title');
            if (b === w) {
                resTitle.innerText = "å¹³å±€";
                resTitle.style.color = "#fff";
            } else if ((b > w && human === 1) || (w > b && human === 2)) {
                resTitle.innerText = "èƒœåˆ©ï¼";
                resTitle.style.color = "#64d2ff";
            } else {
                resTitle.innerText = "å¤±è´¥";
                resTitle.style.color = "#ff4d4d";
            }

            document.getElementById('res-score').innerText = `é»‘å­ ${b} : ç™½å­ ${w}`;
            document.getElementById('result-overlay').style.display = 'flex';
            document.getElementById('eval-loading').style.display = 'block';
            document.getElementById('eval-content').style.display = 'none';

            // å¼‚æ­¥è·å–è¯„ä»·
            try {
                const evaluation = await evaluateGame(gameRecord);
                displayEvaluation(evaluation);
            } catch (error) {
                console.error('è¯„ä»·ç”Ÿæˆå¤±è´¥:', error);
                document.getElementById('eval-loading').innerText = 'è¯„ä»·ç”Ÿæˆå¤±è´¥';
            }
        }

        function displayEvaluation(evaluation) {
            document.getElementById('eval-loading').style.display = 'none';
            document.getElementById('eval-content').style.display = 'block';

            // è®¾ç½®è¯„çº§å¾½ç« 
            const ratingBadge = document.getElementById('rating-badge');
            ratingBadge.innerText = evaluation.rating;
            if (evaluation.ratingColor) {
                ratingBadge.style.background = evaluation.ratingColor;
            }

            // è®¾ç½®å„é¡¹æ•°æ®
            document.getElementById('best-move-rate').innerText = evaluation.bestMoveRate;
            document.getElementById('avg-think-time').innerText = evaluation.avgThinkTime;
            document.getElementById('total-moves').innerText = evaluation.totalMoves;
            document.getElementById('game-duration').innerText = evaluation.gameDuration;

            // æ˜¾ç¤ºå»ºè®®
            if (evaluation.tips && evaluation.tips.length > 0) {
                document.getElementById('tips-box').style.display = 'block';
                const tipsContent = document.getElementById('tips-content');
                tipsContent.innerHTML = evaluation.tips.map(tip =>
                    `<div class="tip-item">${tip}</div>`
                ).join('');
            } else {
                document.getElementById('tips-box').style.display = 'none';
            }
        }

        function draw() {
            ctx.clearRect(0, 0, S, S);
            let validMoves = getValidMoves(board, turn);
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    ctx.fillStyle = COLORS.BOARD;
                    ctx.fillRect(c * G, r * G, G, G);
                    ctx.strokeStyle = COLORS.GRID;
                    ctx.strokeRect(c * G, r * G, G, G);
                    let cx = c * G + G / 2, cy = r * G + G / 2, rad = G / 2 - 10;
                    if (board[r][c] !== 0) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, rad, 0, Math.PI * 2);
                        ctx.fillStyle = board[r][c] === 1 ? COLORS.BLACK : COLORS.WHITE;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "rgba(0,0,0,0.5)";
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (!gameOver && turn === human && validMoves.some(m => m.r === r && m.c === c)) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                        ctx.fillStyle = COLORS.ACCENT;
                        ctx.fill();
                    }
                }
            }
            let bCount = board.flat().filter(x => x === 1).length;
            let wCount = board.flat().filter(x => x === 2).length;
            document.getElementById('score').innerText = `é»‘: ${bCount} | ç™½: ${wCount}`;
            document.getElementById('status').innerText = turn === human ? "è½®åˆ°ä½ äº†" : "AI æ€è€ƒä¸­ (æ·±åº¦:" + searchDepth + ")";
        }

        canvas.addEventListener('mousedown', (e) => {
            if (turn !== human || gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const c = Math.floor((e.clientX - rect.left) / G), r = Math.floor((e.clientY - rect.top) / G);
            if (isValidMove(board, r, c, human)) {
                board = makeMove(board, r, c, human, true);
                nextTurn();
            }
        });
    </script>
</body>

</html>

</html>
